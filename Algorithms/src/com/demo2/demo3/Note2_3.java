package com.demo2.demo3;

/**
 * @author Cheung
 * @date 2021/4/10 8:18
 * 快速排序
 */
public class Note2_3 {
    /*
    本节的主题是快速排序，应用很广泛。快速排序流行的原因就是它实现简单，适用于各种不同的输入数据而且在一般应用中比其他排序算法都要快得多。
    特点：原地排序（只需要一个很小的辅助栈），且将长度为N的数组排序所需的时间和NlgN成正比。
        快速排序的内循环比大多数排序算法都要短小，这意味着他无论是在理论上还是在实际中都要更快。
    缺点：非常脆弱，在实现时要小心才能避免低劣的性能。

    2.3.1 基本算法
        快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并并将整个数组归并以将
        整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况下，递归调用发生在处理整个数组之前；第二种情况下，递归调用发生在处理整个数组之后。
        在归并排序种，一个数组被等分为两半；而在快速排序中，切分（partition）的位置取决于数组的内容
        见类【Quick】
        快速排序递归地将子数组a[lo..hi]排序，先将partition()方法将a[j]放到一个合适的位置，然后再用递归调用将其他位置的元素排列。
        该方法的关键在于切分，这个过程使得数组满足下面三个条件：
        （1）对于某个j，a[j]已经排定
        （2）a[lo]到a[j-1]中的所有元素都不大于a[j]
        （3）a[j+1]到a[hi]中所有元素都不小于a[j]
        我们就是通过递归地调用切分来排序的。
        因为切分过程总是能排定一个元素，用归纳法不难证明递归能够正确地将数组排序：如果左子数组和右子数组都是有序的，那么由左子数组（有序且没有任何元素大于切分元素）、切分元素和右子数组
        （有序且没有任何元素小于切分元素）组成地结果数组也一定是有序的。
        他是一个随机化的算法，因为他在将数组排序之前会将其随机打乱。
        要完成这个实现，需要实现切分方法。一般策略是是随意的取a[lo]作为切分元素，即那个将会被排定的元素，然后我们从数组地左侧开始向右扫描直到找到一个大于等于它地元素，在从数组的右端开始
        向左扫描直到找到一个小于等于它地元素。这两个元素显然是没有排定的，因此我们交换他们的位置。如此继续，我们就会保证左指针i地左侧元素都不大于切分元素，右指针j地右侧元素都不小于切分元素。
        当两个指针相遇时，我们只需要将切分元素a[lo]和左子数组最右侧地元素a[j]交换然后返回j即可。
        2.3.1.1 原地切分
        如果使用一个辅助数组，我们可以很容易地是实现切分，但将切分后地数组复制回去地开销也许使得我们得不偿失。一个初级java程序员甚至可能会将空数组创建在递归的切分方法中，这会大大降低排序的速度。
        2.3.1.2 别越界
        如果切分元素是数组中最小或最大的那个元素，我们就要小心别让扫描指针跑出数组的边界。partition()实现可进行明确的检测来预防这种情况。测试条件（j==lo）是冗余的，因为切分元素就是
        a[lo]，他不可能比自己小，他不可能比自己小。数组右端也有相同的情况，它们都是可以去掉的。
        2.3.1.3 保持随机性
        数组元素的顺序是被打乱过的。因为算法2.5(Quick)对所有数组一视同仁，它的所有子数组也都是随机排序的。这对于预测算法的运行时间很重要。保持随机性的另一种方法是在partition()中随机选择一个切分元素。
        2.3.1.4 终止循环
        正确的检测指针是否越界需要一点技巧，并不像看上去那么容易。一个最常见的错误是没有考虑到数组中可能包含和切分元素的值相同的其他元素。
        2.3.1.5 处理切分元素值有重复的情况
        如算法2.5所示，左侧扫描最好是在遇到大于等于切分元素值的元素时停下，右侧扫描则是遇到小于等于切分元素值的元素时停下。尽管这样可能会不必要的将一些等值的元素交换，但在某些典型应用中，
        他能避免算法的运行时间变为平方级别，
        2.3.1.6 终止递归
        实现快速排序时一个常见的错误就是不能保证将切分元素放入正确的位置，从而倒置程序在切分元素正好是子数组的最大或是最小元素时陷入了无限的递归循环之中。
   2.3.2 性能特点
        快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较。这种简洁性也是快速排序的一个优点，很难想象排序算法中还能有比这更短小的内循环了。
        归并排序和希尔排序一般都比快速排序慢，其原因就是它们还在内循环中移动数据。
        快速排序另一个优势在于它的比较次数很少。排序效率最终还是依赖切分数组的效果，而这依赖于切分元素的值。切分将一个较大的随机数组分成两个随机子数组，而实际上这种分割可能发生在数组的任意位置
        （对于元素不重复的数组而言）
   2.3.3 算法改进
        2.3.3.1 切换到插入排序
            和大多数递归排序算法一样，改进快速排序性能一个简单办法基于以下两点：
            （1）对于小数组，快速排序比插入排序慢
            （2）因为递归，快速排序的sort()方法在小数组中也会调用自己
            因此，在排序小数组时应该切换到插入排序。
            将if(hi<=lo) return; 改为if(hi<=lo+M) {Insertion.sort(a,lo,hi);return;}其中参数M是与系统相关的，但是5~15之间的任意值在大多数情况下都能令人满意
        2.3.3.2 三取样切分
            改进快速排序性能的第二个办法是使用子数组的一小部分元素来切分数组。这样做得到的切分更好，但代价是需要计算中位数。人们发现将取样大小设为3并用大小居中的元素切分的效果最好。
            我们还可以将取样元素放在数组末尾作为“哨兵”来去掉partition()的数组边界测试。
        2.3.3.3 熵最优的排序
            实际应用中经常常出现含有大量重复元素的数组，例如性别等。在这种情况下，我们实现的快速排序的性能尚可，但还有巨大的改进空间。例如，一个元素全部重复的子数组就不需继续排序了，但我们的算法还是会将其切分为更小的数组。
            在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的改进潜力，将当前实现的线性对数级的性能提高到线性级别。
            一个简单的想法是将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。这种切分实现起来比我们目前使用的二分法更复杂，人们为解决它想出了许多不同的办法。
            新的排序算法从左到右遍历数组一次，维护一个指针lt使得a[lo..i-1]中的元素都小于v，一个指针gt使得a[gt+1..hi]中的元素都大于v，一个指针i使得a[lt..i-1]中的元素等于v,a[i..gt]中的元素还未确定。
            一开始i和lo相等，我们使用Comparable接口（而非less()）对a[i]进行三向比较来直接处理以下情况：
            （1）a[i]小于v，将a[lt]和a[i]交换，将lt和i都加一
            （2）a[i]大于v，将a[gt]和a[i]交换，将gt减一
            （3）a[i]等于v，将i加一
            这些操作都会保证数组元素不变且缩小gt-i的值（这样循环才会结束）。另外，除非和切分相等，其他元素都会被交换
            {命题M}不存在任何基于比较的排序算法能够保证在NH-N次比较之内将N个元素排序，其中H为由主键值出现频率定义的香农信息量。
            {命题N}对于大小为N的数组，三向切分的快速排序需要~(2ln2)NH次比较。其中H为由主键值出现频率定义的香农信息量。
            三向切分的最差情况是所有主键均不相同。当存在重复主键时，它的性能就会比归并排序好的多。更重要的是，这两个性质一起说明了三向切分是信息量最优的，即对于任意分布的输入，最优的
            基于比较的算法平均所需的比较次数和三向切分的快速排序平均所需的比较次数相互处于常数因子范围之内。
            对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均时间，大幅偏离的情况非常罕见，因此可以肯定三向切分的快速排序的运行时间和输入的信息量的N倍是成正比的。
            在实际中这个性质很重要，因为对于包含大量重复元素的数组，他将排序时间从线性对数降低到了线性级别。这和元素的排列顺序没有关系，因为算法会在排序之前将其打乱以避免最坏情况。
            元素的概率分布决定了信息量的大小，没有基于比较的排序算法能够用少于信息量决定的比较次数完成排序。这种重复元素的适应性使得三向切分的快速排序称为排序库函数的最佳算法选择--需要
            将包含大量重复元素的数组排序的用例十分常见。








     */
}
