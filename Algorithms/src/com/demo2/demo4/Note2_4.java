package com.demo2.demo4;

/**
 * @author Cheung
 * @date 2021/4/13 10:10
 * 优先队列
 */
public class Note2_4 {
    /*
    优先队列
    许多应用程序都需要处理有序的数组，但不一定要求它们全部有序，或是不一定要一次就将它们排序。许多情况下我们会收集一些元素，处理当前键值的最大元素，然后再收集更多的元素，再处理当前键值最大的元素，如此这般。
    在这种情况下，一个合适的数据结构应该支持两种操作：删除最大元素和插入元素。这种数据类型叫做优先队列。优先队列的使用和队列（删除最老的元素）以及栈（删除最新的元素）类似，但高效地实现它则更有挑战性。
    在本节中，简单的讨论优先队列的基本表现形式（其一或者两种操作都能在线性时间内完成）之后，我们会学习基于二叉堆数据结构的一种优先队列的经典实现方法，用数组保存元素并按照一定条件排序，以实现
    高效地（对数级别的）删除最大元素和插入元素操作。
    优先队列的一些重要的应用场景包括模拟系统，其中事件的键即为发生的时间，而系统需要按照时间顺序处理所有事件；任务调度，其中键值对应的优先级决定了应该首先执行哪些任务；数值计算，键值代表计算错误，
    而我们需要按照键值指定的顺序来修正它们。
    通过插入一列元素然后一个个的删掉其中最小的元素，我们可以用优先队列实现排序算法。一种名为堆排序的重要排序算法也来自于基于堆的优先队列的实现。
    2.4.1 API
        优先队列是一种抽象数据类型，他表示了一组值和对这些值的操作，它的抽象层使我们能够方便地将应用程序（用例）和我们将在本节中学习的各种具体实现隔离开来。
        优先队列最重要的操作就是删除最大元素和插入元素，所以我们会把精力集中在它们身上。删除最大元素的方法名为delMax()，插入元素的方法名为insert()。按照惯例，我们只会通过辅助函数less()来比较
        两个元素，和排序算法一样。如果允许重复元素，最大表示的是所有最大元素之一。为了将API定义完整，我们还加入了构造函数和一个空队列测试方法。为了保证灵活性，我们在实现中使用了泛型，将实现了
        comparable接口的数据的类型作为参数key。这使得我们不必再区别元素和元素的键，对数据类型和算法的描述也将更加清晰和简洁。例如：我们将用“最大元素”代替“最大键值”或是“键值最大的元素”。
        如果需要进行操作的输入量十分巨大，我们可以采用：
        （1）将输入排序然后从中找出M个最大（最小）的元素。这种做法十分耗费时间。
        （2）将每个新的输入和已知的M个最大元素进行比较，但除非M较小，否则这种比较的代价非常高昂。
        这要我们能高效的实现insert()和delMin()，
        见类【TopM】
    2.4.2 初级实现
    我们可以使用有序或无序的数组或链表。在队列较小时，大量使用两种主要操作之一时，或是所操作元素的顺序已知时，他们十分有用。
        2.4.2.1 数组实现（无序）
            或许实现队列的最简单的方法就是基于2.1节下压栈的代码.insert（）方法的代码和栈的push方法完全一样。要实现删除最大元素，我们可以添加一段类似于选择排序的内循环的代码，将最大元素和边界元素
            交换然后删除它，和我们对栈的pop（）方法的实现一样。和栈类似，我们也可以调整数组大小的代码来保证数据结构中至少含有四分之一的元素而又永远不会溢出。
       2.4.2.2 数组实现（有序）
            另一种方法就是在insert()方法中添加代码，将所有较大的元素向右移动一格以使数组保持有序（和插入排序一样）。这样最大的元素总是会在数组的一边，优先队列的删除最大元素操作就和栈的pop（）操作一样了。
       2.4.2.3 链表表示法
            我们可以用基于链表的下压栈的代码作为基础，而后可以选择修改pop()来找到并返回最大元素，或是修改push()来保证所有元素为逆序并用pop()来删除并返回列表的首元素（也就是最大的元素）。
            使用无序序列时解决这个问题的{惰性方法}，我们仅在必要的时候才会采取行动（找出最大元素），使用有序序列则是解决问题的积极方法，因为我们会尽可能未雨绸缪（在插入元素时就保持列表有序），
            使后续操作更高效。
            实现栈或者队列与实现优先队列的最大不同在于对性能的要求。对于栈和队列，我们的实现能够在常数时间内完成所有操作；而对于优先队列，我们刚刚讨论过的所有初级实现中，插入元素和删除最大元素这两个操作
            之一在最坏情况下需要线性时间来完成。我们接下来要讨论的基于数据结构堆的实现能够保证这两种操作都能更快的执行。
    2.4.3 堆的定义
        数据结构二叉堆能够很好的实现优先队列的基本操作。在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。相应的，这些位置的元素又至少要大于等于数组中的另两个元素，以此类推。
        如果我们将所有的元素画成一棵二叉树，将每个较大元素和两个较小的元素用边连接就可以很容易看出这种结构。
        {定义：堆有序}当一颗二叉树的每个结点都大于等于它的两个子结点时，他被称为堆有序。
        相应地，在堆有序的二叉树中，每个结点都小于等于它的父结点（如果有的话）。从任意结点向上，我们都能得到一列非递减的元素；从任意的结点向下，我们都能得到一列非递增的元素。
        特别的：{命题O}根结点是堆有序的二叉树中的最大结点。
        二叉堆表示法：
        如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父结点和两个子结点各需要一个）。如果我们使用完全二叉树，表达就会变得特别方便。
        要画出这样一颗完全二叉树，可以先定下根节点，然后一层一层地由上向下、从左到右，在每个结点的下面连接两个更小的结点，直至将N个结点全部连接完毕。完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树
        的结点按照层级顺序放入数组中，根节点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4、5、6和7，以此类推
        {定义：二叉堆}二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）
        在一个堆中，位置k的结点的父结点的位置为[k/2]，而它的两个子结点的位置分别为2k和2k+1.这样在不使用指针的情况下我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层就令k等于k/2，向下一层则令k等于
        2k或2k+1
        用数组（堆）实现的完全二叉树的结构是很严格的，但它的灵活性已经足以让我们高效的实现优先队列。用他们我们将能实现对数级别的插入元素和删除最大元素的操作。利用在数组中无需指针即可沿树上下移动的便利和以下性质，
        算法保证了对数复杂度的性能
        {命题P}一棵大小为N的完全二叉树的高度为[lgN]
    2.4.4 堆的算法
        我们用长度为N+1的私有数组pq[]来表示一个大小为N的堆。我们不会使用pq[0]，堆元素放在pq[1]至pq[N]中。在排序算法中，我们只通过私有辅助函数less()和exch()来访问元素，但因为所有的元素都在数组pq[]中，我们
        使用更为紧凑的实现方法，不再将数组作为参数传递。堆的操作首先会进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。我们称这个过程叫做堆的有序化。
        堆实现的比较和交换方法见类【MaxPQ】less()和exch()方法
        在堆的有序化过程中，我们会遇到两种情况。当某个结点的优先级上升（或是在堆底加入一个新的元素时），我们需要由下向上恢复堆的顺序。当某个结点的优先级下降（例如将根结点替换为一个较小的元素时），我们需要
        由上至下恢复堆的顺序。
        2.4.4.1 由下至上的堆有序化（上浮）
            如果堆的有序状态因为某个结点变得比他的父结点更大而被打破，那么我就需要通过交换它和它的父结点来修复堆。交换后，这个结点比它的两个子结点都大（一个是曾经的父结点，另一个比它更小，因为她是曾经父结点的子结点）
            但这个结点仍然可能比它现在的父结点更大。我们可以一遍遍的用同样的办法恢复秩序，将这个结点不断向上移动直到我们遇到了更大的父结点。只要记住位置k的结点的父结点的位置是[k/2]，这个过程实现起来很简单。
            类【MaxPQ】中的swim方法中的循环可以保证只有位置k上的结点大于它的父结点时堆的有序状态才会被打破。因此只要该结点不再大于他的父结点，堆的有序化状态就恢复了。
        2.4.4.2 由上至下的堆有序化（下沉）
            如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么我们可以通过将它和它的两个子结点中的较大者交换来恢复堆，将结点向下移动直到它的子结点都比它更小或是到达了堆的底部。
            由位置为k的结点的子结点位于2k和2k+1可以直接得到对应的代码。
          sink()和swim()方法是高效实现优先队列API的基础，原因如下：
          （1）插入元素。我们将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置
          （2）删除最大元素，我们从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置。
          它对优先队列API的实现能够保证插入元素和删除最大元素这两个操作的用时和队列的大小仅呈对数关系。
          见类【maxPQ】
          有限度列由一个基于堆的完全二叉树表示，存储于数组pq[1..N]中，pq[0]没有使用。在insert()中，我们将N加一并把新元素添加到数组最后，然后用swim()恢复堆的秩序。
          在delMax()中，我们从pq[1]中得到需要返回的元素，然后将pq[N]移动到pq[1]，将N减一并用sink()恢复堆的秩序。同时我们还将不再使用的pq[N+1]设为null，以便系统回收它所占的空间。
          {命题Q}对于一个含有N个元素的基于堆的优化队列，插入元素操作只需不超过(lgN+1)次比较，删除最大元素的操作需要不超过2lgN次比较。
          对于需要大量混杂的插入和删除最大元素的典型应用来说，命题Q意味着一个重要的性能突破。使用有序或是无序数组的优先队列的初级实现总是需要线性时间来完成其中一种操作，但基于堆的实现则能够保证在对数时间内完成它们。
       2.4.4.3 多叉堆
          基于用数组表示的完全三叉树构造堆并修改相应的代码并不困难。对于数组中1至N的N个元素，位置k的结点大于等于位于3k-1,3k和3k+1的结点，小于等于位于[(k+1)/3]的结点。甚至对于给定的d，将其修改为任意的d叉树也并不困难。
          我们需要在树高（logdN）和在每个结点的d个子结点找到最大者的代价之间找到折中，这取决于实现的细节以及不同操作的预期相对频繁程度。
       2.4.4.4 调整数组的大小
          我们可以添加一个没有参数的构造函数，在insert()中添加将数组长度加倍的代码，在delMax()中添加将数组长度减半的代码。
          这样处理过后，算法的用例就无需关注各种队列大小的限制。当优先队列的数组大小可以调整，队列长度是任意值时，命题Q指出的对数时间复杂度上限就只是针对一般性的队列长度N而言了。
       2.4.4.5 元素的不可变性
          优先队列存储了用例创建的对象，但同时假设用例代码不会改变它们（改变它们就可能打破堆的有序性）。我们可以将这个假设转化为强制条件，但一般不采取，因为增加代码的复杂度会降低性能。
       2.4.4.6 索引优先队列
          在很多应用中，允许用例引用已经进入优先队列中的元素是有必要的。做到这一点的一种简单方法是给每个元素一个索引。另外，一种常见的情况是用例已经有了总量为N的多个元素，而且可能还同时使用多个（平行）
          数组来存储这些元素的信息。此时，其他无关的用例代码可能已经在使用一个整数索引来引用这些元素了。
         {命题Q续}在一个大小为N的索引优先队列中，插入元素（insert）、改变优先级（change）、删除（delete）和删除最小元素（remove the minimum）操作所需的比较次数和logN成正比
       2.4.4.7 索引优先队列用例
         多向归并问题：将多个有序的输入流归并为一个有序的输出流
    2.4.5 堆排序
        我们可以把任意优先队列变成一种排序方法。将所有元素插入一个查找最小元素的优先队列，然后再重复调用删除最小元素的操作来将它们按顺序删去。用无序数组实现的优先队列这么做相当于进行一次插入排序。用基于堆的优先队列这样做
        是一种新的排序方法--堆排序。
        堆排序可以分为两个阶段。在堆的构造阶段中，我们将原始数组重新组织进一个堆中；然后在下沉排序阶段，我们从堆中按递减顺序取出所有元素并得到排序结果。我们将使用一个面向最大元素的优先队列并删除
        最大元素。为了排序的需要，我们不再将优先队列的具体表示隐藏，并将直接使用swim()和sink()操作。这样我们在排序时就可以将需要排序的数组本身作为堆，因此无需任何额外空间。
      2.4.5.1 堆的构造
        给N个给定的元素构造一个堆可以采用两种方法：swim()或者sink()操作，
        （1）swim()操作：从左向右遍历数组，用swim()保证扫描指针左侧的所有元素已经是一棵堆有序的完全树即可，就像连续向优先级队列中插入元素一样。
        （2）sink()操作；从右至左用sink()函数构造子堆。数组的每个位置都已经是一个子堆根节点了。sink()对于这些子堆也适用。如果一个结点的两个子结点已经是堆了，那在该结点上调用sink()可以将
        它们变成一个堆。这个过程会递归地建立起堆的秩序。开始时我们只需要扫描数组中的一半元素，因为我们可以跳过大小为1的子堆。最后我们在位置1上调用sink()方法，扫描结束。在排序的第一阶段，堆的
        构造方法和我们的想象有所不同，因为我们的目标是构造一个堆有序的数组并使最大元素位于数组的开头，而非构造函数结束的末尾。
        {命题R}用下沉操作由N个元素构造堆只需少于2N次比较以及少于N次交换。
        见类【IndexMinPQ】sort()方法
        这段代码用sink()方法将a[1]到a[N]的元素排序，for循环构建了堆，然后while循环将最大的元素a[1]和a[N]交换并修复了堆。如此重复直到堆变空。
     2.4.5.2 下沉排序
        堆排序的主要工作都是在第二阶段完成的。这里我们将堆中的最大元素删除，然后放入堆缩小后空出的位置。这个过程和选择排序有些类似（按照降序而非升序取出所有元素），但所需的比较要少很多，因为
        堆提供了一种从未排序部分找到最大元素的有效方法。
        {命题S}将N个元素排序，堆排序只需少于(2NlgN+2N)次比较(以及一半次数的交换)
        尽管这段程序中循环的任务各不同（第一段循环构造堆，第二段循环在下沉排序中销毁堆），他们都是基于sink()方法。
     2.4.5.3 先下沉后上浮
        大多数在下沉排序期间重新插入堆的元素会被直接加入到堆底。
















     */
}
