package com.demo2.demo2;

/**
 * @author Cheung
 * @date 2021/4/7 11:05
 */
public class Note2_2 {
    /*
    在本节中我们所要讨论的算法都是基于归并这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。
    很快人们根据这个操作发明了一种简单的归并排序算法：归并排序。
    要将一个数组排序，可以先（递归的）将它分为两半分别排序，然后将结果归并起来。归并排序最重要的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比。它的主要缺点则是他所需的额外空间和N成正比。

    2.2.1 原地归并的抽象方法
        实现归并的一种直截了当的方法是将两个不同的有序数组归并到第三个数组中，两个数组中的元素应该都实现了Comparable接口。实现的方法很简单，创建一个适当大小的数组然后将两个输入数组的元素一个一个的
        从小到大的放进这个数组中。
        但是，当用归并将一个大数组排序时，我们需要进行很多次归并，因此在每次归并时都可以创建一个新数组来存储排序结果会带来问题。我们希望有一种能够在原地归并的方法，这样就可以先将前半部分排序，再将后半部分排序，
        然后在数组中移动元素而不需要使用额外的空间，这样的实现是很复杂的。
        见类【Merge】的merge方法
        该方法先将所有的元素复制到aux[]中。方法在归并时（第二个for循环），进行了4个for循环：左半边用尽（取右半边元素），右半边用尽（取左半边元素），右半边的当前元素小于左半边的当前元素（取右半边的元素）以及右半边的
        的当前元素大于等于左半边的当前元素（取左半边的元素）。
    2.2.2 自顶向下的归并排序
        算法2.4基于原地归并的抽象实现了另一种递归归并，这也是应用高效算法设计中分治思想的最典型的一个例子。这段递归代码是归纳证明算法能够正确地将数组排序的基础：如果它能将两个子数组排序，他就能通过归并两个子数组
        来将整个数组排序。
        见类【Merge】
        要对数组a[lo..hi]进行排序，先将它分为a[lo..mid]和a[mid..hi]两部分，分别通过递归调用将它们单独排序，最后将有序的子数组归并为最终的排序结果。
        通过分析类的调用轨迹，我们可以得知：sort()方法的作用就在于安排多次merge()方法调用的正确顺序。
        {命题F}对于长度为N的任意数组，自顶向下的归并排序需要(NlgN)/2至NlgN次比较
        {命题G}对于长度为N的任意数组，自顶向下的归并排序最多需要访问顺序数组6NlgN次。
        命题F和命题G告诉我们归并排序所需的时间和NlgN成正比。它表明我们只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序。可以用归并排序处理数百万甚至更大规模的数组。
        这是插入排序或者选择排序做不到的。归并操作的主要缺点是辅助数组所使用的额外空间和N的大小成正比。另一方面，通过一些细致的思考我们能够大幅度缩短归并排序的运行时间。
        2.2.2.1 对小规模子数组使用插入排序
            用不同的方法处理小规模问题能改进大多数递归算法的性能，因为递归会使小规模问题中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法。
            对排序来说，我们已经知道插入排序（或者选择排序）非常简单，因此很可能在小数组上比归并排序更快。
        2.2.2.2 测试数组是否已经有序
            我们可以添加一个判断条件，如果a[mid]小于等于a[mid+1]，我们就认为数组已经是有序的并且跳过merge()方法。这个改动不影响排序的递归调用，但是任意有序的子数组算法的运行时间就变为
            现行的了。
        2.2.2.3 不将元素复制到辅助数组
            我们可以节省将数组元素复制到用于归并的辅助数组所用的时间（但空间不行）。要做到这一点我们要调用两种排序方法，一种将数据从输入数组排序到辅助数组，一种将数据从辅助数组排序到
            输入数组。我们要在递归调用的每个层次交换输入数组和辅助数组的角色。
     2.2.3 自底向上的归并排序
        递归实现的归并排序是算法设计中分治思想的典型应用。我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。尽管我们考虑的问题是归并两个大数组，实际上我们
        归并的数组大多数都非常小。实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。
        这种实现方法比标准递归方法所需要的代码量更少。首先我们进行的是两两归并（把每个元素想象成一个大小为1的数组），然后是四四归并（将两个大小为2的数组归并为一个有4个元素的数组），
        然后是八八的归并，一直下去。
        在每一轮的归并中，最后一次归并的第二个子数组可能比第一个子数组要小（但这对merge()不是问题），如果不是的话所有的归并中两个数组大小都应该一样，而在下一轮中子数组的大小会翻倍。
        {命题H}对于长度为N的任意数组，自底向上的归并排序需要(NlgN)/2至NlgN次比较，最多访问数组6NlgN次。
        当数组长度为2的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同。
        自底向上的归并排序比较适合用链表组织的数据。如果我们将链表先按大小为1的子链表进行排序，然后是大小为2的子链表，然后是大小为4的子链表等。
        这种方法只需要重新组织链表链接就能将链表原地排序（不需要创建任何新的链表结点）。
        自顶向下或是自底向上的方式实现任何分治类的算法都很自然。归并排序告诉我们，当能够用其中一种方法解决一个问题时，你都应该试试另一种。
    2.2.4 排序算法的复杂度
        学习归并排序的一个重要原因是它是证明计算复杂性领域的一个重要结论的基础，而计算复杂性能够帮助我们理解排序自身固有的难易程度。计算复杂性在算法设计中扮演着非常重要的角色，而这个结论
        正式和排序算法的设计直接相关的。
        研究复杂度的第一步是建立一个计算模型。一般来说，研究者会尽量寻找一个和问题相关的最简单的模型。对排序来说，我们的研究对象是基于比较的算法，它们对数组元素的操作方式
        是由主键的比较决定的。一个基于比较的算法在两次比较之间可能会进行任意规模的计算，但他只能通过主键之间的比较得到关于某个主键的信息。因为我们局限于实现了Comparable接口的
        对象，本章中的所有算法都属于这一类。
        {命题J}归并排序是一种渐进最优的基于比较排序的算法。
        归并排序的局限性：
        （1）归并排序的空间复杂度不是最优的
        （2）在实践中不一定会遇到最坏情况
        （3）除了比较，算法的其他操作（例如访问数组）也可能很重要
        （4）不进行比较也能将某些数据排序

     */
}
