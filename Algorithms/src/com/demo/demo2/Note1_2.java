package com.demo.demo2;

/**
 * @author Cheung
 * @date 2021/2/9 9:27
 * 数据抽象
 */
public class Note1_2 {
    /*1.2数据抽象
    （1）数据类型：一组值和一组对这些值的操作的集合
    （2）数据抽象：定义和使用数据类型，这个过程就称为数据抽象
    （3）Java编程的基础主要是使用class关键字构造被称为引用类型的数据类型，这种编程风格也被称为“面向对象编程”
         因为他的核心概念是对象，即保存了某个数据类型的值的实体。我们可以定义自己的数据类型来抽象任意对象
    （4）抽象数据类型（ADT）：是一种能够对使用者隐藏数据表示的数据类型。用Java类来实现抽象数据类型和用一组静态方法实现一个函数库并没有什么不同。
         主要不同在于它实现了数据和函数的实现关联，并且将数据的表示方法隐藏起来。在使用抽象数据类型时，我们的注意力集中在API描述的操作上而不去关心数据的表示；
         在实现抽象数据类型时，我们的注意力集中在数据本身的并将实现对该数据的各种操作。
         ADT之所以重要是因为在程序设计上他们支持封装。
     */
    /*1.2.1使用抽象数据类型：
        1.2.1.1 抽象数据类型的API
        我们使用API（应用程序编程接口）来说明抽象数据类型的行为。他将列出所有构造函数和实例方法（即操作）并简要描述他们的功用；
        尽管数据类型定义的基础是一组值的集合，但在API中可见的仅是对他们的操作，而非他们的意义。
        因此，抽象数据类型的定义和静态方法库之间有许多共同之处：
            （1）两者的实现均为Java类
            （2）实例方法可能接受0个或多个指定类型的参数，由括号表示并且由逗号分隔
            （3）他们可能会返回一个指定类型的值，也可能不会（用void表示）
        当然，他们也有三个显著的不同：
            （1）API中可能会出现若干个名称和类名相同且没有返回值的函数，这种特殊的函数被称为“构造函数”。
            （2）实例方法不需要static 关键字。他们不是静态方法---他们的目的就是操作该数据类型中的值
            （3）某些实例方法的存在就是为了尊重Java的习惯--我们将此类方法称为继承的方法并在API中将他们显示为灰色、
        1.2.1.2 继承的方法
        1.2.1.3 用例代码
        1.2.1.4 对象
        对象是能够继承数据类型的值的实体。所有对象都有三大重要特性：状态，标识和行为。
            （1）状态：即数据类型中的值
            （2）标识：能够将一个对象区别于另一个对象，我们可以认为对象的标识就是他在内存中的位置
            （3）行为：就是数据类型的操作
        数据类型的实现的唯一职责就是维护一个对象的身份，这样用例代码在使用数据类型时只需遵守描述对象行为的API即可，而无需关注对象状态的表示方法。
        对象的状态可以为用例代码提供信息，或是产生某种副作用，或是被数据类型的操作所改变，但数据类型的值的表示细节和用例代码是无关的。
        “引用”是访问对象的一种方式。Java使用术语引用类型以示和原始数据类型（变量和值关联）的区别。不同的Java实现中引用的实现细节也各不相同，但可以认为引用就是内存地址。
        1.2.1.5 创建对象
        每种数据类型中的值都存储于一个对象中。要创建（或实例化）一个对象，我们用关键字new并紧跟类名以及（）（或在括号内指定一系列的参数，这个取决于构造函数是否需要）来触发他的构造函数。
        构造函数没有返回值，因为他总是返回他的数据类型的对象的引用。每当用例调用了new（），系统会做如下操作
            *为新的对象分配内存空间
            *调用构造函数初始化对象中的值
            *返回该对象的一个引用
        和原始数据类型不同的是，变量关联的是指向对象的引用而非数据类型的本身，这个区别就是 Counter head=new Counter("head");String head="head";
        左边为构造函数创建了引用对象，而右边则是为一个字符串赋了值。这是两种不同的操作。
        1.2.1.6 调用实例方法
        实例方法的意义在于操作数据类型中的值。区别于静态方法，非静态（实例）方法的每次触发都是和一个对象相关的。
            *静态方法主要作用是实现函数；
            *非静态（实例）方法主要作用是实现数据类型的操作
        两者都可能出现在用例代码中，但很容易就可以区分它们：静态方法调用的开头是类名（习惯为大写），而静态方法调用的开头为对象名（一般为小写）。
        区别如下：
                                    实例方法                                    静态方法
                举例：           heads.increment();                        Math.sqrt(2.0);
                调用方法：            对象名                                       类名
                参量：           对象的引用和方法的参量                           方法的参数
                主要作用：        访问或改变对象的值                              计算返回值

        1.2.1.7 使用对象
        【见Flips类】
        1.2.1.8 赋值语句
        我们来看下面的语句
        Counter c1=new Counter("ones");
        c1.increment();
        Counter c2=c1;
        c2.increment();
        StdOut.println(c2);
        输出的结果为：2 ones，我们需要注意，这两个对象c1,c2其实是指向的一个引用，也就是说，我们可以将c2理解为c1的另一个名字，那对c2所作的操作，势必会影响到他们共同的引用，因此c1所引用的值也会发生改变。
        这是我们应该尽量避免的。这是面向对象的一个特性，c1,c2所引用的就是一个对象，而非两个独立的对象。
        todo 这里并不是很理解
        1.2.1.9 将对象作为参数
        和原始数据类型不同的是，虽然我们调用方法都是按值传递，但是将对象作为参数时，他是能够通过调用方法来改变参数的值的，比如Counter中的increment（）方法，他就改变了Counter对象的一个计数器参数，使其+1，
        而静态方法我们往往需要另外一个对象来接受返回的值，这是两种不同性质的操作。
        1.2.1.10 将对象作为返回值
        【见FlipsMax类】
        因为对象可以有多个参数值，所以我们可以通过一个返回语句来返回多个值。由于Java的返回值只能有一个，所以我们可以利用一个对象作为返回值来返回多个值
        todo 这里并不是很理解
        1.2.1.11 数组也是对象
        在Java中，所有非原始数据类型都是对象。也就是说----数组其实也是对象，也就是说，我们将数组放在赋值语句的右端时，我们都是在创建这个数组引用的一个副本，
        而非将数组的每个元素的数据给到了另外一个数组，创建了数组的副本。也就是说，我们对这两个引用的操作，都可以直接影响到他们所对应的对象，这样我们就可以直接来修改对象，而不用一直使用一个对象来操作数组。
        1。2.1.12 对象的数组
        数组的元素可以是任意数据类型的，也就是说我们不仅可以创建基本数据类型的数组，当然也可以创建引用数据类型的数组，创建这样的数组
        【见类Rolls】
        步骤为；
        （1）使用方括号语法调用数组的构造函数创建对象
        （2）对于每个数组元素调用它的构造函数创建相应的对象
        在Java中，对象数组就是一个由对象的引用所组成的数组，而非对象自身组成的数组。如果对象很大，那么在操作移动他们时只需要操作引用而不必操作对象自身，这会提升效率；
        但在对象很小时，反而会降低效率

        总结-----运用数据抽象的思想编写代码（定义和使用数据类型，将数据类型的值封装在对象内）的方式称为面向对象编程。
            *数据类型--指的是一组值和一组对值的操作的集合。我们将数据类型实现在独立的Java类模块中并编写他们的用例。
            *对象--能够存储任意该数据类型的值的实体，或数据类型的实例。包括三大关键性质：状态，标识，行为。
        一个数据类型的实现所支持的操作如下：
            *创建对象（创建它的标识）：使用new关键字触发构造函数并创建对象，初始化对象中的值并返回它的引用；
            *操作对象中的值（控制对象的行为，可能会改变对象的状态）：使用和对象关联的变量调用实例方法来对对像的值进行操作
            *操作多个对象：创建对象的数组，像原始数据类型的值一样将他们传递给方法或是从方法中返回，只是变量关联的是对象引用而非对象本身。
        面向对象编程，使得我们能够自己创建非原始数据类型的自己定义的数据类型，而且在调用API时我们不需要知道它内部具体的操作，具体的数据类型，
        我们通过封装好了的对象来通过类提供的接口就能够实现对对象的值的改变以及状态的改变。
        总的来说，面向对象使得我们不用再每次都去操作对象的每个变量，而是通过相应的操作的方法来改变这些值，我们只需要调用我们需要的实例方法，就能够实现我们想要的效果


     */

    /*1.2.2 抽象数据类型枚举
        实际上，我们编写的每一个Java程序实现的都是某种数据类型（或是一个静态方法库）。
        使用到的所有数据类型：（1）java.lang.*中的标准系统抽象数据类型，可以被任意java程序调用
                          （2）java标准库中的抽象数据类型，如java.swt、java.net和java.io，它们也可以被任意java程序调用，但需要import语句
                          （3）I/O处理类抽象数据类型，允许我们处理多个输入输出流
                          （4）面向数据类抽象数据类型，他们的主要作用是通过封装数据的表示简化数据的组织和处理。
                          （5）集合类抽象数据类型，他们的主要用途是简化对同一类型的一组数据的操作。
                          （6）面向操作的抽象数据类型，我们用他们分析各种算法
                          （7）图算法相关的抽象数据类型，它们包括一些用来封装各种图的表示的面向数据的抽象数据类型，和一些提供图的处理算法的面向操作的抽象数据类型

      1.2.2.1 几何对象
         三种常用的集合对象相对应的抽象数据类型：（1）Point2D[平面上的点]（2）Interval1D[直线上的间隔]（3）Interval2D[平面上的二维间隔，即和数轴对齐的长方形]
         【一个具体的应用见Interval2DTest类】
      1.2.2.2 信息处理
         我们可以将数据类型的组织方式进行构建，利用多种方法来使得其可以处理多种输入的数据类型而不用再踯躅与具体的数据类型。每当遇到逻辑上相关的不同类型的数据时，我们都可以定义一个抽象数据类型，
         从而简化使用者的代码和API的调用。
      1.2.2.3 字符串
         java的String是一种抽象数据类型，一个String值是一串可以由索引访问的char值，字符串的API中有许多定义好的方法。
         String值和字符数组类似，但是两者之间是有区别的，数组是通过java内置的语法来访问每个字符，String则为索引访问、字符串长度以及其他许多操作准备了实例方法。
         另一方面，我们可以直接使用字符串字面量String来创建并初始化一个字符串而非使用构建函数，我们还可以使用“+”直接来拼接字符串而非concat()方法。
         使用String而非字符串数组的原因是为了保证代码的简洁清晰、有了String类型，我们不必再关系字符串的表示方法
         【见StringTest类】
      1.2.2.4 再谈输入输出
        利用面对对象编程，我们就能定义类似的机制来在一个程序中同时处理多个输入流、输出流和图像。
        在In和Out的API时，会首先尝试在当前目录内查找文件，如果查找不到，则认为字符串为一个网站的名称并且尝试连接到那个网站（若网站不存在，异常结束）。
        无论哪种情况，指定的文件或网站都会成为被创建的输入或输出流对象的来源和目标，所有的read*（）和print*（）方法都会指向那个文件和网站。
        这种机制使得单个程序能够处理多个文件和图像；你也可以将这些对象赋给变量将他们作为方法的参数，作为方法的返回值或者创建他们的数组，可以像操作任何类型的对象那样操作它们。

     1.2.3 抽象数据类型的实现
        定义一个抽象的数据类型：
            （1）文件的第一部分语句会定义表示数据类型的值的实例变量
            （2）第二部分为实现对数据类型的值的操作的构造函数
            （3）实例方法（实例方法可以是公共的[在API中说明]，也可以是私有的[用于辅助计算，用例无法使用]）
        一个抽象的数据类型中可能含有多个构造函数，而且可能含有静态方法，特别是单元测试用例main
        【见CounterTest类】
      1.2.3.1 实例变量
        要定义数据类型的值（即每个对象的状态），我们需要声明实例变量，声明的方式和局部变量方式类似。
        两者的区别在于：每个时刻每个局部变量只有一个值，但每个实例变量则对应着无数值（数据类型的每个实例对象都会只有一个），这并不会产生二义性，因为我们在访问实例变量时必须要需要通过一
                    个对象--我们访问的是这个对象的值
        每个实例变量的声明都需要一个可见性修饰符。在抽象数据类型的实现中，我们会使用private(想使用者隐藏数据类型中的数据表示)。如果该值在初始化之后不应该再被改变，我们也会使用修饰符final。
        例如在CounterTest中有两个类型的值，如果我们用public来修饰它们，那么根据定义,这种数据类型就不再是抽象的了。
      1.2.3.2 构造函数
        每个Java类都至少含有一个构造函数以创建一个对象的标识。构造函数类似于一个静态方法，但它能够直接访问实例变量并且没有返回值。
        一般来说，构造函数的作用是初始化实例变量。每个构造函数都将创建一个对象并且向调用者返回一个该对象的引用。构造函数的名称总是和类名相同。
        我们可以和重载方法一样重载这个名称并且定义签名不同的多个构造函数。如果没有定义构造函数，类将会隐式定义一个默认情况下不接受任何参数的构造函数并且将所有实例变量初始化为默认值。
        （int/float=0,bool=false,引用=null）。我们可以在声明语句中初始化这些实例变量并改变这些默认值。
        当用例使用关键字new时，java会自动触发一个构造函数。重载构造函数一般将用于将实例变量由默认值初始化为用例提供的值。
      1.2.3.3 实例方法
        实现数据类型的实例方法（每个对象的行为）的代码和实现静态方法（函数）的代码完全相同。每个实例方法都有一个返回值类型、一个签名（它指定了方法名、所有参数变量的类型和名称）
        和一个主体（由一系列语句组成，包括一个返回语句来将一个返回类型的值传递给调用者）。
        当调用者触发了一个方法时，方法的参数（如果有）均会被初始化为调用者所提供的值，方法的语句会被执行，得到一个返回值并且将该值返回给调用者。
        他的效果就好像调用者代码中的函数调用被替换为了这个返回值。
        实例方法的所有这些行为都和静态方法相同，只有一点关键的不同：它们可以访问并操作实例变量。
        在一个实例方法中对变量的引用指的是===》引用该方法的对象中的值，因此我们只要使用：对象.方法名就可以访问对象的实例变量并且做出操作。
        {一个使用变量的重要方式：通过触发一个实例方法来操作该对象的值}
        这跟调用静态方法===》直接方法名（参数）似乎只有语法上的区别，但是这种操作使得面向对象的方法得以实现，使得方法和对象绑定在了一起。
      1.2.3.4 作用域
        我们使用了三种变量：参数变量；局部变量；实例变量
        前两者的用法和静态变量中一样：方法的签名定义了参数变量，在方法被调用时参数变量会被初始化为调用者提供的值；局部变量的声明和初始化都在方法的主体中，也只在该方法内生效。、
        参数变量的作用范围为整个方法体内。
        实例变量则完全不同,它们为该类的对象保存了数据类型的值，他们的作用域是整个类（若出现二义性，则用this前缀来区别实例变量）【理解实例方法中这三种变量的区别是理解面向对象编程的关键】见下例：
          private int var;

          private void method1(){
              int var;
              var=0;//这里的var为局部变量var
              this.var=1;//这里的var为实例变量
          }
          private void method2(){
              var=2;//这里的var为实例变量
          }
      1.2.3.5 API、用例与实现
        要完全理解一个数据类型，我们需要他的API、典型用例和它的实现。
        我们开发每种数据类型都会遵循以下步骤（我们思考的不是应该采取什么行动来达成某个计算性的目的，而是用例的需求）：
        （1）定义一份API：API的作用是将使用和实现分离，以实现模块化编程。我们制定一份API的目标有二：
               1、我们希望用例的代码清晰而正确，事实上，在最终确定API之前就编写一些用力代码来确保所设计的数据类型操作正是用例所需要的是很好的主意。
               2、我们希望能够实现这样的操作，定义一些无法实现的操作是没有意义的。
        （2）用一个Java类实现API的定义：首先我们选择适当的实例变量，然后再编写构造函数和实例方法。
        （3）实现多个测试用例来验证前两步做出的设计决定（我们一般将用例独立成为一个具有静态方法main的类，并将数据类型定义中的main方法预留为一个用于开发和最小单元测试的测试用例，并且至少调用每个实例方法一次）

    1.2.4 更多抽象数据类型的实现
      1.2.4.1 日期
        本书中反复出现的一个主题就是我们需要理解各种实现对空间和时间的需求以及它们对各种用例的实用性。在实现中使用数据抽象的一个关键优势是我们可以将一种实现替换为另一种而无需改变用例的任何代码。
        【见DateTest类】
      1.2.4.2 维护多个实现
        同一份API的多个实现可能会产生维护和命名问题、在这种情况下，我们可能只是想将较老的实现替换为改进的实现。而在另一些情况下，我们可能需要维护两种实现，
        一种适用于某些用例，另一种适用于另一些用例。
        实际上，本书的一个主要目标就是深入讨论若干种基本抽象数据类型的实现并衡量他们的性能的不同。
        在本书中，我们经常会比较同一份API的两种不同实现在同一个用例中性能表现。为此，我们通常采用一种非正式的命名规则：
         （1）通过前缀的描述性修饰符区别同一份API的不同实现。例如，我们可以将上1。2.4.1的日期实现命名为BasicData和SmallData。
             我们有可能还需要创建一个判断日期是否合理的SmartData
         （2）维护一个没有前缀的参考实现，他应该适用于绝大多数用例的需求。在这里，大多数用例应该直接会使用Data
        这种方式在一个庞大的系统中有可能和不太理想，因为我们需要修改用例的代码。
      1.2.4.3 累加器
        【见Accumulator类】
        该实现用于维护一个int类型的实例变量来记录已经处理过的数据值的数量以及一个double类型的实例变量来记录所有数据量的平均值。
        该实现没有保存数据的值--它可以用于处理大规模的数据（甚至是在一个无法全部保存他们的设备上），而一个大型系统也可以大量使用累加器。
        这种特性可能会被忽视，所以应该将其在API中注明。因为一种存储所有数据的实现可能使调用它的应用程序用光所有内存。
      1.2.4.4 可视化的累加器
        【见VisualAccumlator类】


    1.2.5 数据类型的设计
        抽象数据类型是一种向用例隐藏内部表示的数据类型。
      1.2.5.1 封装
       面向对象的编程特性之一就是使用数据类型的实现封装数据，以简化实现和隔离用例开发。封装实现了模块化编程。它允许我们：
            （1）独立开发用例和实现的代码；
            （2）切换至改进的实现而不会影响用例的代码
            （3）支持尚未编写的程序（对于后续用例，API能够起到指南的作用）
       封装同时也隔离了数据类型的操作。使得：
            （1）限制潜在的错误
            （2）在实现中添加一致性检查等测试工具
            （3）确保用例代码更明确
       一个封装的数据类型可以被任意调用，因此它拓展了Java语言。我们所提倡的编程风格是将大型程序分解为能够独立开发和调试的小型模块，这种方式将修改代码的影响限制在局部区域；
       也促进了代码复用，我们能够使用新的实现来代替老的实现来改进它的性能、准确度或者内存消耗。同样的思想也适用于许多其他领域。
       我们希望开发出更好的算法，在不改进用例代码的前提下来改进所有用例的性能。
       模块化编程成功的关键在于保持模块之间的独立性。我们坚持将API作为用例和实现之间唯一的依赖点。
       【并不需要知道一个数据类型是如何实现的才能实现它，实现数据类型时也应该假设使用者除了API之外什么也不知道】
      1.2.5.2 设计API
        应该按照能够复用的方式来编写每个程序。理想情况下，一份API应该能够清楚地说明所有可能的输入和副作用，然后我们应该先写出检查实现是否与API相符的程序。
        （1）API可能会难以实现，实现的开发分厂困难，甚至不可能。
        （2）API可能会难以使用，用例代码甚至比没有API时更加复杂
        （3）API的范围可能太窄，缺少用例所需的方法
        （4）API的范围可能太宽，包含许多不会被任何用例调用的方法，这种缺陷可能是最常见的，并且是最难以避免的。API的大小一般会随着时间而增长，因此向已有的API中添加
            新的方法很简单，但在不破坏已有用例程序的前提下从中删除方法却很困难。
        （5）API可能太粗略，无法提供有效的抽象
        （6）API可能太详细，抽象过于细致或是发散而无法实现
        （7）API可能会过于依赖某种特定的数据表示：用例代码可能会因此无法从数据表示的细节中解脱出来，要避免这种缺陷是很困难的，因为数据表示显然是抽象数 据类型实现的核心
       总的来说----只为用例提供他们所需要的，仅此而已
     1.2.5.3 算法与抽象数据类型
        数据抽象天生适合算法研究，因为它能够为我们提供一个框架，在其中能够准确的说明一个算法的目的以及其他程序应该如何使用该算法。
        每个Java程序都是一组静态方法和（或）一种数据类型的实现的集合。在本书中我们主要关注的是抽象数据类型的实现中的操作和向用例隐藏其中的数据表示，
        数据抽象使我们能够：
            （1）准确定义算法能为用例提供什么
            （2）隔离算法的实现和用例的代码
            （3）实现多层抽象，用已知算法实现其他算法
        将二分查找重写为一段面向对象的程序
        【见StaticSETofInts】
     1.2.5.4 接口继承
        Java语言为定义对象之间的关系提供了支持，称为接口。
        我们学习的第一种继承机制叫做子类型。它允许我们通过指定一个含有一组公共方法的接口为两个本来并没有关系的类建立一种联系，这两种类都必须实现这些方法。
        【见Datable接口和Data类】
        通过上面类的操作，Java编译器就能检查该实现是否和接口相符。为任意实现了特定方法的类添加了implements Datable保证了所哟用例都能该类的对象调用这些方法。、
        这种方式叫做接口继承---实现类继承的是接口。接口继承使得我们的程序能够通过调用接口中的方法操作实现该接口的任意类型的对象（甚至是还未被创建的类型）。、
        我们能在更多非正式的API中使用接口继承，但为了避免代码依赖于和理解算法无关的高级语言特性以及额外的接口文件，我们并没有这么做。我们用接口来进行比较和迭代
    1.2.5.5 实现继承
        java还支持另一种继承机制，被称为【子类】.这种功能使得程序员不需要重写整个类就能改变它的行为或者为它添加新的功能。
        主要思想：定义一个新类（子类/派生类）来继承另一个类（父类/基类）的所有实例方法和实例变量。子类包含的方法比父类更多。另外，子类可以重新定义或者重写父类的方法。
        子类继承被广泛的应用于所谓可拓展的库，这种方法能够有效的重用潜在的十分庞大的库中的代码。
        我们会尽量避免子类继承，因为这会破坏封装。
   1.2.5.6 字符串表示习惯
        由于默认的Objects的ToString（）方法并没有多大意义，我们一般在自建的类中重写ToString，其实现其实很简单，只需要通过”+“来隐式的调用每个实例变量的ToString方法即可。
   1.2.5.7 封装类型
        Java提供了一些内置的引用类型，称为封装类型。每种原始数据类型都有一个相对应的封装类型，在需要时Java会自动的将原始数据类型转换为封装类型。
        比如说：当一个int值需要和一个String类型进行拼接时，它的类型会自动转换为Integer并触发toString（）方法。
   1.2.5.8 等价性
        如果我们用同样类型的两个引用变量a和b进行等价性测试（a==b），我们检测的是他们的标识（引用）是否相同。一般用例希望能够检查数据类型的值（对象的状态）是否相同
        或者实现某种针对该类型的规则。
        Java的底层实现：
            eg1：如果x和y的返回值均为String类型的值，那么在当且仅当x和y的长度相同并且每个位置的字符均相同时,x.equals(y)的返回值为true.

        在我们定义自己的数据类型时，我们需要重载equals（）方法，Java约定equals（）必须是一种等价关系，他必须有：
            （1）自反性：x.equals(x)为true
            （2）对称性：当且仅当x.equals(y)为true时，y.equals(x)为true
            （3）传递性：如果x.equals(y)为ture,且y.equals(z)为true,则x.equals(z)为true
        另外，它必须接受一个object为参数并且满足以下性质：
            （1）一致性：当两个对象均未被修改时，反复调用x.equals(y)总会返回相同的值
            （2）非空性：x.equals(null)的返回值必须为false
        这些定义都是自然合理的，但是确保这些性质成立并遵守Java的约定，同时又避免在实现时避免做无用功并不容易
        【见DateTest2类重写的equals()方法】，该equals（）方法可以作为其他实现的模板
    1.2.5.9 内存管理
        我们为引用变量赋予一个新的值，因此一段程序可能会产生一个无法引用的对象，
        如下例
        public static void main(String[] args) {
            DateTest2 a=new DateTest2(1,5,2009);
            DateTest2 b=new DateTest2(2,6,2019);
            a=b;
        }
        在经过a=b后，a和b都指向了同一个Data对象，并且不存在能够引用初始化变量a的那个Data对象的引用了。
        本来该对象的唯一引用就是变量a，但是该引用被赋值语句覆盖了，这样的对象称为孤儿。
        对象在离开作用域之后会变成孤儿。
        Java程序经常会创建大量的对象（以及许多保存原始数据类型值的变量），但在某个时刻程序只会需要它们中的一小部分。
        因此，编程语言和系统需要某种机制来在必要时为数据类型的值分配内存，而在不需要时释放他们的内存（对于一个对象来说，有时是在他变成孤儿之后）
        Java的垃圾回收会动态回收内存
   1.2.5.10 不可变性
        所谓不可变数据类型，指的是该类型的对象中的值在创建之后就无法再被改变。
        与此相反，可变数据类型能够通过操作来改变对象的值。Java中一般使用final来修饰不可变的数据类型。
        采用可变/不可变数据类型的原则是在于：我们抽象封装的是否为不变的值。
        不可变数据类型有很多好处，比如调试等等，但我们必须要为每个值创建一个对象，但是我们可以用Java的垃圾回收来处理内存的回收。

        即使我们用final来修饰类内的数据类型，但也有可能绕过API来修改他的值
        见类【Vector 和VectorTest类】
        我们在设计数据类型的对象时要考虑不可变性，而且数据类型是否为不可变的应该在API中说明，这样使用者才知道那些值是不可变的。
   1.2.5.11 契约式设计
        Java语言中能够在程序运行时检验程序状态的一些机制。两种Java的语言特性;
        （1）异常Exception：一般用于处理不受我们控制的不可预见的错误
        （2）断言Assertion：检验我们在代码中做出的一些假设
   1.2..5.12 异常和错误
        异常和错误都是在程序运行中出现的破坏性事件，Java采取的行动为抛出异常或是抛出错误，
        一种叫做快速出错的常规编程实践提倡，一旦出错就立刻抛出异常，使定位出错位置更加容易
   1.2.5.13 断言
        契约式设计的编程思想：
        （1）数据类型的设计者需要说明前提条件（用例在调用某个方法前必须满足的条件）
        （2）后置条件（实现在方法返回时必须达到的要求）
        （3）副作用（方法可能对对象状态产生的任何其他变更）
     */
}
