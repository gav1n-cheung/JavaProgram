package com.demo.demo5;

/**
 * @author Cheung
 * @date 2021/4/1 8:32
 * 案例研究：union-find算法
 */
public class Note1_5 {
    /*为了说明我们设计和分析算法的基本方法，我们现在来学习一个具体的例子。
    我们的目的是强调以下几点：
    （1）优秀的算法因为能够解决实际问题而变得更为重要
    （2）高效算法的代码也可以很简单
    （3）理解某个实现的性能特点是一项有趣而令人满足的挑战
    （4）在解决同一个问题的多种算法之间进行选择时，科学方法是一种重要的工具
    （5）迭代式改进能够使算法的效率越来越高
    我们首先会给出一个简单的方案，然后对它的性能进行研究并由此得出应该如何继续改进我们的算法
     */
    /*
    1.5.1 动态连通性
        首先我们详细的说明一下问题：
        问题的输入是一列整数对，其中每个整数都表示一个某种类型的对象，一对整数pq可以被理解为“p和q是相连的”。我们假设“相连”是一种等价关系，
        这也意味着它具有：
            （1）自反性：p和q是相连的
            （2）对称性：如果p和q是相连的，那么q和p也是相连的
            （3）传递性：如果p和q是相连的，并且q和r是相连的，那么p和r也是相连的。
        等价关系能够将对象分为等价类。在这里，当且仅当两个对象相连时它们才属于同一个等价类。
        我们的目标是编写一个程序来过滤掉序列中所有无意义的整数对（两个整数均来自于同一个等价类中）
        换句话说：当程序从输入中读取了整数对p q时，那么则将这一对整数写入到输出中如果已知的数据可以说明p和q是相连的，那么程序应该忽略p q这对整数并继续处理
        输入中的下一对整数。
        为了达到所期望的效果，我们需要设计一个数据结构来保存程序已知的所有整数对的足够多的信息，并用它判断一堆新对象是否是相连的。
        我们将这个问题通俗的叫做动态连通性问题。这个问题可能有以下的应用
        1.5.1.1 网络
            输入中的整数表示的可能是一个大型计算机网络中的计算机，而整数对则表示网络中的连接。这个程序能够判定我们是否需要在p和q之间
            假设一条新的连接才能进行通信，或是我们可以通过已有的链接在两者之间建立通信线路；或者这些整数表示的可能是电子电路中的触电，
            而整数对表示的是连接处点之间的电路；或者这些整数表示的可能是社交网络中的人等等。
        1.5.1.2 变量名等价性
            某些编程环境允许两个等价的变量名（指向同一个对象的多个引用）。在一系列这样的声明之后，系统需要能够判别两个给定的变量名是否等价。
        1.5.1.3 数字整合
            在更高的抽象层次上，可以将输入的所有整数看做属于不同的数学集合。在处理一个整数对p q时，我们是在判断它们是否属于相同的集合。
            如果不是，我们会将p所属的集合和q所属的集合归并到同一个集合。
            我们使用网络方面的术语，将对象称为触点，将整数对称为连续，将等价类称为连通分量或是简称分量。简单起见，假设我们有用0到N-1的整数所表示的
            N个触点。这样做并不会降低算法的通用性，因为我们会将整数标识符和任意名称关联起来。

            我们在设计算法时面对的第一个任务就是精确地定义问题。我们希望算法解决的问题越大，他完成任务所需的时间和空间可能就越多。
            我们不可能预先知道这期间的量化关系，而且我们通常只会在发现解决问题很困难，或是代价巨大，或是在幸运地发现算法所提供的信息比原问题
            所需要的更加有用时修改问题。
            例如：连通性问题只要求我们的程序能够判别给定的整数对p q是否相连，但并没有要求给出两者之间的道路上的所有连接。
                这样的要求会使问题更加困难，并得到另一组不同的算法。
            为了说明问题，我们设计了一份API来封装所需的基本操作：初始化、连接两个触点、判断包含某个触点的分量、判断两个触点是否存在于同一个分量之中以及返回所有分量的数量。
            见类【UF】
            API：如果两个触点在不同的分量中，则union（）操作会将两个分量合并。find操作会返回给定触点所在的连通分量的标识符。connected（）操作能够判断两个触点是否存在于同一个分量之中。
                count()方法会返回所有连通分量的数量。一开始我们有N个分量，将两个分量归并的每次union()操作都会使分量总数-1；
            为解决动态连通性问题设计算法的任务就转化成了实现这份API。所有的实现都应该：
                （1）定义一种数据结构表示已知的连续
                 (2）基于此数据结构实现高效的union()、find()、connected()和count()方法
            众所周知，数据结构的性质会直接影响到算法的效率，因此数据结构和算法的设计是紧密相关的。
            API和分量都已经说明了触点和分量都会用int来表示，所以我们可以用一个以触点为索引的数组id[]作为基本的数据结构来表示所有分量。
            我们将使用分量中的某个触点名称作为分量的标识符，因此你可以认为每个分量都是由它的触点之一所表示的。
            一开始，我们拥有N个分量，每个触点都构成了一个只含有他自己的分量，因此我们将id[i]的值初始化为i，其中i在0~N-1之间。
            对于每个触点i，我们将find()方法用来判定他所在的分量所需的信息保存在id[i]之中。connected()方法的实现只用一条语句find(p)==find(q)，它返回一个布尔值，我们在所有方法的实现中都会用到connected方法。
            总之，我们起点就是算法【UF】，我们维护了两个实例变量，一个是连通分量的个数，一个是分量数组id[]。使得find（）对于处于同一个连通分量中的触点均返回相同的整数值。union（）方法必须保证这一点。

            为了测试API的可用性并方便开发，我们在main（）方法中包含了一个用例用于解决动态连通问题。
            它会从输入中读取N值以及一系列整数对，并对每一对整数调用connected()方法方法：如果某一对整数中的两个触点已经连通，程序会继续处理下一对数据；如果连通不成立，则程序会调用union()方法并打印这对整数。
            为了分析算法，我们将重点放在不同算法访问任意数组元素的总次数上。我们这样做相当于隐式地猜测各种算法在一台特定的计算机上的运行时间在这个量乘以某个常数的范围之内。这个猜想基于代码，用实验验证他并不困难。
            我们将会看到，这个猜想是算法比较的一个很好的开始。
            {union-find的成本模型}，在研究实现union-find的API的各种算法时，我们统计的是数组的访问次数（无论读写）。

   1.5.2 实现
        我们将讨论三种不同的实现，他们均根据以触点为索引的id[]数组来确定两个触点是否存在于相同的连通分量中。
        1.5.2.1 quick-find算法
            一种方法是保证当且仅当id[p]等于id[q]时p和q是连通的。换句话说：在同一个连通分量中的所有触点在id[]中的值必须全部相同。这就意味着connected(p,q)只需要判断id[p]==id[q]，
            当且仅当p和q在同一连通分量中该语句才会返回true值。为了调用union(p,q)确保这一点。我们首先要检查它们是否已经同一个连通分量中。如果是我们就不需要采取任何行动，否则我们面对的情况就是p所在的连通分量
            中的所有触点的id[]值均为一个同一个值，而q所在的连通分量中的所有触点的id[]值均为另一个值。要将这两个分量合二为一，我们必须将两个集合中所有的触点所对应的id[]元素变为同一个值。
            为此我们需要遍历整个数组，将所有和id[p]相等的元素的值变为id[q]的值。我们也可以将所有和id[q]相等的元素变为和id[p]的值---两者皆可。
       1.5.2.2 quick-find算法的分析
            find（）操作的速度显然是很快的，因为它只需要访问一次id[]数组，但quick-find算法一般无法处理大型的问题，因为对于每一对输入union()都需要扫描整个id[]数组。
            {命题F}在quick-find算法中，每次find()调用只需要访问数据一次，而归并两个分量的union操作访问数组的次数在（N+3）到(2N+1)之间。
            {证明}由代码马上可以知道，每次connected()调用都会检查id[]数组中的两个元素是否相等，即会调用两次find()方法。归并两个分量的union()操作会调用两次find，检查id[]数组中的全部N个元素并改变
                它们中1~N-1个元素的值。
            在测试较大的数据时，quick-find算法就速度很慢，显然我们需要寻找更好的算法。
            todo:树的理解
       1.5.2.3 quick-union算法
            我们要讨论的下一个算法的重点是提高union()方法的速度，他和quick-find算法是互补的。他也基于相同的数据结构--以触点作为索引的id[]数组，但我们赋予这些值的意义不同，我们需要用它们来定义更加复杂的结构。
            确切的说，每个触点所对应的id[]元素都是同一个分量中的另一个触点的名称（也有可能是自己的）--我们将这种联系称为链接。在实现find()方法时，我们从给定的触点开始，由他的链接得到另一个触点，再由这个触点的链接到达
            第三个触点，如此继续跟随着链接直到到达一个根触点，即链接指向自己的触点（你将会看到，这样的一个触点必然存在）。当且仅当分别由两个触点开始的这个过程到了同一个根触点时它们存在于同一个连通分量之中。
            为了保证这个过程的有效性，我们需要union(p,q)来保证这一点。它的实现很简单，我们由p和q的链接分别找到他们的根触点，然后只需将一个根触点链接到另一个即可将这一个分量重命名为另一个分量,因此这个算法叫做quick-union。
            和刚才一样，无论是重命名含有p的分量还是重命名含有q的分量都可以。
      1.5.2.4 森林的表示
            quick-union算法的代码很简洁，但有些难以理解。用节点表示触点，用从一个节点到另一个节点的箭头表示链接，由此得到数据结构的图像表示使我们理解算法的操作变得相对容易。
            我们得到的结构是树--从技术上来说，id[]数组用父链接的形式表示了一片森林。为了简化图表，我们常常会省略链接的箭头（因为它们全都指向上）和树的根节点中指向自己的链接。
            无论我们从任何触点所对应的节点开始跟随链接，最终都将达到含有该节点的树的根节点。可以用归纳法证明这个性质的正确性：在数组被初始化之后，每个节点的链接都指向他自己；如果在某次
            union()操作之前这条性质成立，那么操作之后它必然也成立。因此，quick-union中的find()方法能够返回根节点对应的触点的名称（这样connected才能够判定两个触点是否在同一棵树中）
            这样的表示方法对于这个问题很实用，因为当且仅当两个触点存在于相同的分量之中时它们对应的节点才会在同一棵树中。另外，构造树并不困难：quick-union中union()的实现只用了一条语句就将一个根节点变为另一个
            根节点的父节点，从而归并了两棵树。
     1.5.2.5 quick-union算法的分析
            我们可以将quick-union看做是quick-find算法改良，因为它解决了quick-find算法中最主要的问题（union总是线性的）。对于一般的输入数据这个变化显然是一次改进，但quick-union仍然存在问题，
            我们不能保证在所有情况下他都能比quick-union算法快得多。
            {定义}一棵树的大小是他的节点的数量。树中的一个节点的深度是它到根节点的路径上的链接数。树的高度是他所有节点中的最大深度。
     1.5.2.6 加权quick-union算法
            我们只需简单修改quick-union算法就能保证像这样的糟糕情况不再出现。与其在union()中将一棵树连接到另一棵树，我们现在会记录每一棵树的大小并总是将最小的树连接到较大的树上。
            这项改动需要添加一个数组和一些代码来记录书中的节点数，他将大大改进算法的效率。我们将它称为加权quick-union算法。
            见类【WeightedQuickUnion】
     1.5.2.8 加权quick-union算法的分析
            根据正文所述的森林表示方法这段代码很容易理解。我们加入了一个由触点索引的实例变量数组sz[]，这样union()就可以将小树的根节点连接到大树的根节点上去。这使得算法能够处理较大规模的问题。
            对于动态连通性问题，命题H和它的推论的实际意义在于加权quick-union算法是三种算法中唯一可以用于解决大型实际问题的算法。加权quick-union算法处理N个触点和M条连接时最多访问数组cMlgN次，其中c
            为常数。这个结果和quick-find算法（以及某种情况下的quick-union算法）需要访问数组至少MN次形成了鲜明的对比。因此，有了加权quick-union算法我们能保证能够在合理的时间范围内解决实际中的大规模动态
            连通性问题。只需要多写几行代码，我们所得到的程序在处理实际应用中的大型动态连通性问题时就会比简单的算法快了数百万倍。
            针对大规模问题的经验性研究告诉我们，加权quick-union算法在解决实际问题时一般都能在常数时间内完成每个操作，我们可能很难找到比它效率更高的算法了。
     1.5.2.8 最优算法
            进行了路径压缩的quick-union算法是最优的算法，但并非所有操作都能在常数时间内完成。
     1.5.2.9 均摊成本的图像

   1.5.3 展望
        研究基础问题的基本步骤：
        （1）完整而详细地定义问题，找出解决问题所必需的基本抽象操作并定义一份API
        （2）简洁地实现一种初级算法，给出一个精心组织的开发用例并使用实际数据作为输入
        （3）当实现所能解决的问题地最大规模达不到期望时决定改进还是放弃
        （4）逐步改进实现，通过经验性分析或（和）数学分析验证改进后地效果
        （5）用更高层次的抽象表示数据结构或算法来设计更高级地改进版本
        （6）如果可能尽量为最坏情况下的性能提供保证，但在处理普通数据时也要有良好的性能
        （7）在适当的时候将更细致地深入研究留给有经验的研究者并继续解决下一个问题











     */



}
